use std::{fmt, future::Future};

use serde::{Deserialize, Serialize};

pub(crate) type Error = Box<dyn std::error::Error + Send + Sync + 'static>;

pub use icp_macros::icp;

#[non_exhaustive]
#[derive(Clone, Debug, PartialEq, Default)]
pub struct Context {
    /// The AWS request ID generated by the Lambda service.
    pub request_id: String,
    /// The execution deadline for the current invocation in milliseconds.
    pub deadline: u64,
    /// The ARN of the Lambda function being invoked.
    pub invoked_function_arn: String,
    /// The X-Ray trace ID for the current invocation.
    pub xray_trace_id: String,
}

/// A trait describing an asynchronous function `A` to `B.
pub trait Handler<A, B> {
    /// Errors returned by this handler.
    type Error;
    /// The future response value of this handler.
    type Fut: Future<Output = Result<B, Self::Error>>;
    /// Process the incoming event and `Context` then return the response asynchronously.
    fn call(&mut self, event: A, context: Context) -> Self::Fut;
}

/// Returns a new `HandlerFn` with the given closure.
pub fn handler_fn<F>(f: F) -> HandlerFn<F> {
    HandlerFn { f }
}

/// A `Handler` implemented by a closure.
#[derive(Clone, Debug)]
pub struct HandlerFn<F> {
    f: F,
}

impl<F, A, B, Error, Fut> Handler<A, B> for HandlerFn<F>
where
    F: Fn(A, Context) -> Fut,
    Fut: Future<Output = Result<B, Error>> + Send,
    Error: Into<Error> + fmt::Debug,
{
    type Error = Error;
    type Fut = Fut;
    fn call(&mut self, req: A, ctx: Context) -> Self::Fut {
        (self.f)(req, ctx)
    }
}

pub async fn run<A, B, F>(handler: F) -> Result<(), Error>
where
    F: Handler<A, B>,
    <F as Handler<A, B>>::Error: fmt::Debug,
    A: for<'de> Deserialize<'de>,
    B: Serialize,
{
    println!("works?");
    // let mut handler = handler;
    Ok(())
}